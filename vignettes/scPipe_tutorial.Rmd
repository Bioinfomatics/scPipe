---
title: "scPipe: a flexible data preprocessing pipeline for 3' end scRNA-seq data"
author: "Luyi Tian"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{scPipe: flexible data preprocessing pipeline for 3' end scRNA-seq data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



# Introduction

`scPipe` is a package designed to process scRNA-seq data generated by different protocols. It is designed for protocols with UMI, but can also adapt to non-UMI protocols. `scPipe` consist of two major components. The first is data preprocessing with raw fastq as input and a gene count matrix as output. The second component starts from the gene count matrix, includes quality control and a shiny app for clustering and visualization.

# Case Study: Preprocessing CEL-seq2 data

CEL-seq2 is a modified version of the CEL-seq method with higher sensitivity and lower cost. It uses a polyT primer with index sequences to capture a cell's mRNA. The index sequence consists of the a cell specific index, which is designed, and a molecular index, also called unique molecular identifier (UMI), which is randomly generated and different for each primer. The ouput fastq of CEL-seq2 is paired-ended where the first read contains the transcript and second read has the cellindex+UMI with some polyA sequence.

## Getting started

We begin by creating a folder to store the results.

```{r,eval=TRUE}
library(scPipe)
library(SingleCellExperiment)
data_dir = tempdir()
```

## Organising the files

To process the data, we need the genome fasta file, gff3 exon annotation and a cell barcode annotation. The barcode annotation should be a `.csv` file with at least two columns, where the first column has the the cell id and the second column contains the barcode sequence. We use ERCC spike-in genes for this demo. All files can be found in `extdata` folder of the `scPipe` package:

```{r}
# file path:
ERCCfa_fn = system.file("extdata", "ERCC92.fa", package = "scPipe")
ERCCanno_fn = system.file("extdata", "ERCC92_anno.gff3", package = "scPipe")
barcode_annotation_fn = system.file("extdata", "barcode_anno.csv", package = "scPipe")
```

The read structure for CEL-seq2 is a paired-ended reads with first longer read mapped to transcript and second shorter read consist of 6bp UMI followed by 8bp cell barcode. **NOTE**: by convention, `scPipe` always assumes `read1` refers to the read with the transcript sequence, and is usually the longer read. These data are also available in the in `extdata` folder:

```{r,eval=TRUE}
fq_R1 = system.file("extdata", "simu_R1.fastq.gz", package = "scPipe")
fq_R2 = system.file("extdata", "simu_R2.fastq.gz", package = "scPipe")
```

## Data Preprocessing

The pipeline starts with fastq file reformatting. We move the barcode and UMI to the read name and keep the transcript, so the output read name looks like `@[barcode_sequence]*[UMI_sequence]#[readname]` ... The read structure in our example dataset is paired-ended reads, with the cell barcode in read 2 in position start at position 6 in the read and the UMI sequence also in read 2 starting at the first position. So the read structure will be : `list(bs1=-1, bl1=0, bs2=6, bl2=8, us=0, ul=6)`. `bs1=-1, bl1=0` means we don't have an index in read 1 so we set a negative value its start position and give it zero length. `bs2=6, bl2=8` means we have index in read two which starts at position 6 in the read and is 8 bases in length. `us=0, ul=6` means we have a UMI at the start of read two which is 6 bases long. **NOTE**: we use a zero based index system, so the indexing of the sequence starts at zero.

```{r,eval=TRUE}
sc_trim_barcode(file.path(data_dir, "combined.fastq"),
                fq_R1,
                fq_R2,
                read_structure = list(bs1=-1, bl1=0, bs2=6, bl2=8, us=0, ul=6))
```

Then we align reads to the genome. The example uses `Rsubread` but any aligner that support RNA-seq alignment and gives standard BAM output can be used. The `Rsubread` package is not available on Windows platforms, so the following step will not run on Windows.

```{r,eval=TRUE}
if(!(.Platform$OS.type == "windows")){
  Rsubread::buildindex(basename=file.path(data_dir, "ERCC_index"), reference=ERCCfa_fn)

  Rsubread::align(index=file.path(data_dir, "ERCC_index"),
      readfile1=file.path(data_dir, "combined.fastq"),
      output_file=file.path(data_dir, "out.aln.bam"), phredOffset=64)
}

```

After the read alignment we will map reads to exons using the exon annotations. Currently `scPipe` only supports annotation in `gff3` and `bed` format.

```{r,eval=TRUE}
if(!(.Platform$OS.type == "windows")){
  sc_exon_mapping(file.path(data_dir, "out.aln.bam"),
                file.path(data_dir, "out.map.bam"),
                ERCCanno_fn)
}

```

Next we use `sc_demultiplex()` to split the reads to each cell and put them into spearate `.csv` file in `/count` subfolder where each file contains three columns and each row is a read with first column being the gene that the read mapped to, second column is the UMI sequence of this read, the third column is the distance to transcript end position (TES). This file will be used for UMI deduplication and to generate gene counting matrix by callling `sc_gene_counting()`.

```{r,eval=TRUE}
if(!(.Platform$OS.type == "windows")){
  sc_demultiplex(file.path(data_dir, "out.map.bam"), data_dir, barcode_annotation_fn,has_UMI=FALSE)

  sc_gene_counting(data_dir, barcode_annotation_fn)
}

```


Now we complete the preprocessing step. you will find the gene counting matrix at `data_dir/gene_count.csv` and quality control statistics in `data_dir/stat` folder, which can be used in the following step for quality control.


# process data generated by other protocols

the most difference that come from different protocols is the read structure, which is defined by `read_structure` argument in scPipe. The difference between CEL-seq and Drop-seq is the cell barcode is unknown for Drop-seq, so an extra step `sc_detect_bc` is required before `sc_demultiplex`, to identify and generate the cell barcode annotation. To use `run_scPipe` on Drop-seq data, just ignore the `barcode_anno` argument. scPipe is not optimized for the full-lengh protocols like SMART-seq, but it can process the data generated by such protocol by set the `has_UMI` to `FALSE` in `sc_demultiplex` or `run_scPipe`.

## quality control

The easiest way to create a SingleCellExperiment object is using `create_sce_by_dir`, it will read the gene counting matrix as well as the quality control informations in stat folder.

```{r}
if(!(.Platform$OS.type == "windows")){
sce = create_sce_by_dir(data_dir)
dim(sce)
}
```

The dataset we created using ERCC simulated reads only contains 10 cells with perfect quality. So we will use the example dataset in scPipe, which is a part from Christine Biben's blood cells with different cell type that contains 383 cells and 1000 genes, to show the quality control functions in scPipe. This shows the way to create the SingleCellExperiment object without using `create_sce_by_dir`:

```{r}
data("sc_sample_data")
data("sc_sample_qc")
sce = SingleCellExperiment(assays = list(counts =as.matrix(sc_sample_data))) # generate new sce with gene count matrix
QC_metrics(sce) = sc_sample_qc
demultiplex_info(sce) = cell_barcode_matching
UMI_dup_info(sce) = UMI_duplication

```


There are several plots we can create to access the overall quality of the experiment. The first is cell barcode demultiplex statistics. The pie chart shows the percentage of reads that uniquely match a cell barcodes.It also gives, for the unmathced part, their alignmen rate and the percentage of reads mapped to exon. The large proportion of unmatch read mapped to exon indicate a failure of cell barcode demultiplexing.

```{r}
plot_demultiplex(sce)
```

Another plot, which usually used to evaluate the read deapth, is the duplication number of UMIs. The UMI is used to mark each individual molecules and after PCR amplification, the same molecule with have multiple copys, which can be identified and removed by the same UMI sequence. Therefore, the copy number of UMIs is an indication of the PCR amplification rate. 

```{r}
plot_UMI_dup(sce)
```

Then we calculate the QC metrics and use the `detect_outlier` function to find the poor quality cells. The `detect_outlier` has argument `comp` to define the maximum component of the gaussian mixture model. Usually the default value 1 is sufficient, but in case the data is heterogeneous in terms of quality control metrics, the value can be set to 2 or 3 to get a better results. It can only remove low quality cells by `type="low"` or only cells with big sizes `type="high"` or both `type="both"`. The `conf` argument specifies the lower and upper confident interval for outliers, the `detect_outlier` is insensistive to the interval values.

```{r, warning=FALSE, message=FALSE}
sce = calculate_QC_metrics(sce)
sce = detect_outlier(sce)
```

we can plot the alignment statistics for the sample data

```{r}
plot_mapping(sce, percentage = TRUE, dataname = "sc_sample_data")
```

and also the pairwise QC metrics plots:

```{r}
plot_QC_pairs(sce)
```

The last step will be to remove the low quality cells by `remove_outliers`. Since the scater and scran package uses the SingleCellExperiment, it will very easy to continue the pipeline with scater and scran, for normalization and visualization.

```{r}
sce = remove_outliers(sce)
dim(sce)
```



